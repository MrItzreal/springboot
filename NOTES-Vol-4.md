## Advanced JPA Entity and Column Mapping Customizations

JPA provides several annotations to give you fine-grained control over how your Java entities and their fields map to database tables and columns.

### A. Customizing Table Name: `@Table`

- **Purpose:** Allows you to specify the exact name of the database table to which an entity is mapped. This decouples the Java class name from the database table name.
- **Usage:** Applied at the entity class level.
- **Example:**

  ```java
  import jakarta.persistence.Entity;
  import jakarta.persistence.Table;

  @Entity
  @Table(name = "IzzyDev_User_Profiles") // Maps this entity to the "IzzyDev_User_Profiles" table
  public class UserProfile {
      // ...
  }
  ```

- **Benefit:** Useful for adhering to specific database naming conventions or mapping to pre-existing tables. If not used, the table name usually defaults to the entity class name.

### B. Auto-Generating Primary Key Values: `@GeneratedValue`

- **Purpose:** Used in conjunction with `@Id` to indicate that the primary key value for an entity should be generated automatically by the persistence provider (e.g., Hibernate) or the database.
- **Usage:** Applied to the primary key field.
- **Example:**

  ```java
  import jakarta.persistence.Entity;
  import jakarta.persistence.Id;
  import jakarta.persistence.GeneratedValue;
  // import jakarta.persistence.GenerationType; // For specific strategies

  @Entity
  public class Product {
      @Id
      @GeneratedValue // Strategy can be specified, e.g., @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Integer id;
      private String name;
      // ...
  }
  ```

- **Benefit:** Ensures unique primary keys without manual assignment, simplifying entity creation. Different generation strategies (`TABLE`, `SEQUENCE`, `IDENTITY`, `UUID`, `AUTO`) can be chosen based on database capabilities and requirements.

### JPA Primary Key Generation Strategies (`@GeneratedValue`)

When using `@GeneratedValue` with `@Id` to automatically generate primary key values for your entities, JPA (and its provider like Hibernate) offers several strategies. These define _how_ the unique ID is created.

- **`GenerationType.AUTO` (Default)**

  - **Explanation:** The persistence provider (e.g., Hibernate) automatically chooses the most appropriate generation strategy based on the database being used and its capabilities.
  - **Commonly defaults to:** `SEQUENCE` or `IDENTITY`.
  - **Usage:**
    ```java
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO) // Or just @GeneratedValue
    private Long id;
    ```

- **`GenerationType.IDENTITY`**

  - **Explanation:** Relies on an auto-incremented identity column in the database (e.g., `AUTO_INCREMENT` in MySQL, `IDENTITY` in SQL Server, `SERIAL` in PostgreSQL). The ID is generated by the database itself when a new row is inserted.
  - **Consideration:** May limit batch insert capabilities with some JPA providers because the ID is only known after the insert.
  - **Usage:**
    ```java
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    ```

- **`GenerationType.SEQUENCE`**

  - **Explanation:** Uses a database sequence (a database object that generates a sequence of unique numbers). The persistence provider requests the next value from a pre-defined database sequence before an entity is inserted.
  - **Consideration:** Generally offers good performance and is more flexible for batch operations than `IDENTITY`. Requires the sequence to exist in the database (though Hibernate can often create it for you with certain DDL settings).
  - **Usage:**
    ```java
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "my_entity_seq")
    @SequenceGenerator(name = "my_entity_seq", sequenceName = "MY_ENTITY_SEQ_DB", allocationSize = 1)
    private Long id;
    ```
    _(The `@SequenceGenerator` annotation is used to configure the sequence name, allocation size, etc.)_

- **`GenerationType.TABLE`**

  - **Explanation:** Uses a separate database table to simulate a sequence and generate IDs. The persistence provider reads and updates a value in this "generator" table to get the next ID.
  - **Consideration:** This strategy generally has the poorest performance compared to `IDENTITY` or `SEQUENCE` due to the overhead of table locking and extra DML operations. It's less commonly used in modern applications.
  - **Usage:**
    ```java
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "my_table_gen")
    @TableGenerator(name = "my_table_gen", table = "ID_GENERATOR_TABLE", pkColumnName = "GEN_KEY", valueColumnName = "GEN_VALUE", pkColumnValue = "MY_ENTITY_ID", allocationSize = 1)
    private Long id;
    ```
    _(The `@TableGenerator` annotation is used to configure the generator table details.)_

- **`GenerationType.UUID` (or equivalent mechanisms for UUIDs)**

  - **Explanation:** Generates a Universally Unique Identifier (UUID), which is typically a 128-bit value. UUIDs are designed to be unique across different systems and can be generated by the application or sometimes by the database.
  - **Consideration:** Excellent for distributed systems where IDs need to be generated independently without central coordination. Can lead to larger primary key sizes and potentially slightly slower indexing compared to sequential numbers, but this is often acceptable.
  - **Usage (JPA 3.2+):**
    ```java
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private java.util.UUID id;
    ```

Choosing the right strategy depends on your specific database, performance requirements, and whether you need globally unique identifiers.

### C. Customizing Column Mappings: `@Column`

- **Purpose:** Allows customization of how an entity field maps to a database column. Applied at the field level.
- **Common Attributes:**

  - **`name = "column_name"`**: Specifies the exact name of the column in the database table.
    - Example: `lastName` field maps to `user_surname` column.
      ```java
      @Column(name = "user_surname")
      private String lastName;
      ```
  - **`length = value`**: Defines the maximum length for string-based columns (e.g., `VARCHAR(value)`).
    - Example: `description` field maps to a column with a max length of 1000.
      ```java
      @Column(length = 1000)
      private String description;
      ```
  - **`unique = true`**: Adds a unique constraint to the column in the database, ensuring no two rows have the same value for this column.
    - Example: `email` field must be unique.
      ```java
      @Column(unique = true)
      private String email;
      ```
  - **`updatable = false`**: Specifies that the column should not be included in SQL `UPDATE` statements generated by JPA. Once the entity is inserted, the value of this field in its corresponding database column cannot be changed via JPA updates to that entity instance.
    - Example: `creationDate` should not be updatable.
      ```java
      @Column(updatable = false)
      private LocalDateTime creationDate;
      ```
  - **`insertable = false`**: Specifies that the column should not be included in SQL `INSERT` statements generated by JPA. This is useful if the database itself is responsible for setting the column's value (e.g., through a default value, a trigger, or a special database-generated timestamp).
    - Example: `lastModifiedDbTimestamp` is set by the database.
      ```java
      @Column(insertable = false, updatable = false) // Often used together if DB manages it
      private LocalDateTime lastModifiedDbTimestamp;
      ```

- **Combined Example from Learning:**

  ```java
    @Entity
    public class Student {
    @Id
    @GeneratedValue
    private Integer id;

    @Column(name = "c_fname", length = 20)
    private String firstName;

    private String lastName; // Uses default column name "lastName"

    @Column(unique = true)
    private String email;

    @Column(updatable = false, insertable = false)
    private String some_column; // Value managed by DB or not persisted for insert/update
   }
  ```

These annotations provide powerful control over the Object-Relational Mapping (ORM) process, allowing developers to precisely define how their Java objects interact with the database schema.
